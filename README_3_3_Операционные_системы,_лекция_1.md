1. Какой системный вызов делает команда cd? В прошлом ДЗ мы выяснили, что cd не является самостоятельной программой, 
это shell builtin, поэтому запустить strace непосредственно на cd не получится. 
Тем не менее, вы можете запустить strace на /bin/bash -c 'cd /tmp'. В этом случае вы увидите полный список системных вызовов, 
которые делает сам bash при старте. Вам нужно найти тот единственный, 
который относится именно к cd. Обратите внимание, что strace выдаёт результат своей работы в поток stderr, а не в stdout.


Ответ: Узнать список системных вызовов для встроенных в оболочку утилит, мы можем, используя просмотр вызовов, 
выполняемых самим bash при вызове такой утилиты:
gord@igord-virtual-machine:~/devops-netology$ strace -o cd.log /bin/bash -c 'cd /tmp' 

далее, смотрим системные вызовы, сохраненные с помощью ключа -o в файл cd.log: 
igord@igord-virtual-machine:~/devops-netology$ cat cd.log 

видим, что после выполнения всех системных вызовов, связанных с определением и передачей параметров,
вызывается непосредственно системный вызов для смены директории chdir:
chdir("/tmp")
 
chdir изменяет рабочую директорию на директорию, определенную в path.


2. Попробуйте использовать команду file на объекты разных типов на файловой системе. 
Например:

vagrant@netology1:~$ file /dev/tty
/dev/tty: character special (5/0)
vagrant@netology1:~$ file /dev/sda
/dev/sda: block special (8/0)
vagrant@netology1:~$ file /bin/bash
/bin/bash: ELF 64-bit LSB shared object, x86-64

Используя strace выясните, где находится база данных file на основании которой она делает свои догадки.


Ответ:

Из вывода, полученного при выполнении команды strace, мы видим, что  
в конечном итоге тдет обращение к /usr/share/misc/magic.mgc:
openat(AT_FDCWD, "/usr/share/misc/magic.mgc", O_RDONLY) = 3

Из "man magic" мы узнаем, что magic файл является файлом шаблонов для команды file.

3. Предположим, приложение пишет лог в текстовый файл. 
Этот файл оказался удален (deleted в lsof), однако возможности сигналом сказать приложению переоткрыть файлы 
или просто перезапустить приложение – нет. 
Так как приложение продолжает писать в удаленный файл, место на диске постепенно заканчивается. 
Основываясь на знаниях о перенаправлении потоков предложите способ обнуления открытого удаленного файла 
(чтобы освободить место на файловой системе).

Ответ:

a. Запускаем ping c перенаправлением stdout в файл и работой фоновым процессом:
vagrant@vagrant:~$ ping 8.8.8.8 > ping.log &

b. Удаляем файл ping.log
vagrant@vagrant:~$ rm ping.log

c. Фильтруем по ping инфу об используемых процессом ping файлов
vagrant@vagrant:~$ sudo lsof -p 1442 | grep ping
ping    1442 vagrant    1w   REG  253,0   305085 1048609 /home/vagrant/ping.log (deleted)

d. "Обнуляем" файл с дескриптором 1 в директории найденного процесса:
vagrant@vagrant:~$ sudo bash -c "echo -n > /proc/1442/fd/1"


4. Занимают ли зомби-процессы какие-то ресурсы в ОС (CPU, RAM, IO)?

Ответ:
Зомби-процессы- это процесы, которые завершились, но, по каким-то причинам, родительский процесс не получил информацию об этом.
Соответственно, зомби-процессы не занимают ресурсов в ОС, но их не возможно убить, и остается запись в таблице процессов.

5. В iovisor BCC есть утилита opensnoop:

root@vagrant:~# dpkg -L bpfcc-tools | grep sbin/opensnoop
/usr/sbin/opensnoop-bpfcc

На какие файлы вы увидели вызовы группы open за первую секунду работы утилиты? Воспользуйтесь пакетом bpfcc-tools для Ubuntu 20.04. Дополнительные сведения по установке.


Ответ:

igord@igord-virtual-machine:~$ sudo /usr/sbin/opensnoop-bpfcc

PID    COMM               FD ERR PATH
830    vmtoolsd            9   0 /proc/meminfo
830    vmtoolsd            9   0 /proc/vmstat
830    vmtoolsd            9   0 /proc/stat
830    vmtoolsd            9   0 /proc/zoneinfo
830    vmtoolsd            9   0 /proc/uptime
830    vmtoolsd            9   0 /proc/diskstats
1820   Timer-0            98   0 /home/igord/.java/.userPrefs/.user.lock.igord
1413   gnome-shell        21   0 /proc/self/stat
342    systemd-journal    25   0 /proc/1535/comm
342    systemd-journal    25   0 /proc/1535/cmdline
342    systemd-journal    25   0 /proc/1535/status
342    systemd-journal    25   0 /proc/1535/attr/current
342    systemd-journal    25   0 /proc/1535/sessionid
342    systemd-journal    25   0 /proc/1535/loginuid
342    systemd-journal    25   0 /proc/1535/cgroup


6. Какой системный вызов использует uname -a? Приведите цитату из man по этому системному вызову, где описывается альтернативное местоположение в /proc, где можно узнать версию ядра и релиз ОС.


Ответ:

uname() - get name and information about current kernel
Part of the utsname information is also accessible via /proc/sys/kernel/{ostype, hostname, osrelease, version, domainname}.

7. Чем отличается последовательность команд через ; и через && в bash? Например:
root@netology1:~# test -d /tmp/some_dir; echo Hi
Hi
root@netology1:~# test -d /tmp/some_dir && echo Hi
root@netology1:~#
Есть ли смысл использовать в bash &&, если применить set -e?

Ответ:

Оператор (;) служит для последовательного запуска разделенных оператором (;) команд не зависимо от результата выполнения предыдущей команды. 
Следующая команда выполняется после выполнения предыдущей, результат выполнения предыдущей команды не важен.

root@netology1:~# test -d /tmp/some_dir; echo Hi
Hi
В примере выше первой выполняется команда test -d /tmp/some_dir (команда test  -d определяет, существует ли файл (валидность пути и является ли директорией)) , результат выполнения не выводится на stdout, 
поэтому видим только вывод выполнения следующей после оператора (;) команды- echo Hi

оператор && - это управляющий оператор, который необходим для ситуации вида- command1 && command2 - command2 выполнится только в случае успешного выполнения command1 (результат выполнения command1 == 0)
В нашем примере-
root@netology1:~# test -d /tmp/some_dir && echo Hi
root@netology1:~#

Результат выполнения test -d равен 1, т.к. такая директория не существует( результат выполнения команды False == 1), и, т.к. управляющий оператор у нас &&, то переход к команде echo не происходит по определению.
set -e - Немедлено выйти, если значение выполнения команды ($?) - не нулевое значение, т.е. не успешно.
Использовать и set -e и && - не имеет смысла, при ошибке выполнение команды прекратиться. 


8. Из каких опций состоит режим bash set -euxo pipefail и почему его хорошо было бы использовать в сценариях?

Ответ:

-e - прекращает выполнение скрипта если команда завершилась ошибкой, выводит в stderr строку с ошибкой
-u - прекращает выполнение скрипта, если встретилась несуществующая переменная
-x - выводит выполняемые команды в stdout перед выполненинем
-o pipefail - прекращает выполнение скрипта, даже если одна из частей пайпа завершилась ошибкой

Таким образом, при выполнении set с опциями -euxo pipefail выполнение сценария будет более наглядным (за счет -x) и безопасным- благодаря анализу параметров на ошибки.


9. Используя -o stat для ps, определите, какой наиболее часто встречающийся статус у процессов в системе. 
В man ps ознакомьтесь (/PROCESS STATE CODES) что значат дополнительные к основной заглавной буквы статуса процессов. 
Его можно не учитывать при расчете (считать S, Ss или Ssl равнозначными).


Ответ:

igord@igord-virtual-machine:~$ ps -o stat
STAT
Ss - Процесс в ожидании завершения события, лидер сессии.
R+ - Процесс выполняется либо в очереди на выполнение, фоновый. 












