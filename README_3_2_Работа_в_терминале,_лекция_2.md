1. Какого типа команда cd? Попробуйте объяснить, почему она именно такого типа; опишите ход своих мыслей, если считаете что она могла бы быть другого типа.

Ответ:
vagrant@vagrant:~$ type cd
cd is a shell builtin

Итак, cd- команда, встроеная в shell. 
Команды, встроенные в shell, выполняются быстрее, так как нет необходимости искать путь к ним в переменной PATH и запускать их отдельным от shell процессом.
Далее, я полагаю, что можно использовать cd как отдельную утилиту, но проще ее иметь встроенной в shell- если она не будет встроенной,
то потенциально может возникнуть ситуация, когда утилита cd будет отсутствовать в системе, либо ее местоположение не будет прописано в переменной PATH,
что приведет к невозможности ее запуска, а с учетом того, что ее функционал является базовым и его отсутствие приведет к невозможности полноценной работы в
shell, то проще сделать утилиту встроеной, во избежание таких проблем.


2. Какая альтернатива без pipe команде grep <some_string> <some_file> | wc -l? man grep поможет в ответе на этот вопрос. 
Ознакомьтесь с документом о других подобных некорректных вариантах использования pipe.

Ответ:
Исходная команда
grep <some_string> <some_file> | wc -l
Выдает stdout выполнения команды grep на stdin команды wc, опция -l, в свою очередь, выдает количество строк из полученного из stdin потока данных.

Альтернативой команде без pipe является выполнение команды 
grep -c <some_string> <some_file>
где -с - Выдает только количество строк, содержащих <some_string>.

3. Какой процесс с PID 1 является родителем для всех процессов в вашей виртуальной машине Ubuntu 20.04?

Ответ:
Процесс systemd
Можно посмотреть непосредственно информацию о процессе:
vagrant@vagrant:/home$ ps -p 1
Либо выполнить команду lsoft -p 1 :
vagrant@vagrant:/home$ lsof -p 1
либо посмотреть на графическое дерево 
vagrant@vagrant:/home$ pstree -p 1


4. Как будет выглядеть команда, которая перенаправит вывод stderr ls на другую сессию терминала?

Ответ:
Команда будет выглядеть так:
vagrant@vagrant:/home$ ls -l no.file 2> /dev/pts/1

5. Получится ли одновременно передать команде файл на stdin и вывести ее stdout в другой файл? Приведите работающий пример.

Ответ:
Да, например конструкцией вида:
vagrant@vagrant:/home$ cat 0< temp2.file > temp.file

В данном примере комманда cat получит на stdin файл temp2.file и выведет stdout в файл temp.file

6. Получится ли находясь в графическом режиме, вывести данные из PTY в какой-либо из эмуляторов TTY? Сможете ли вы наблюдать выводимые данные?

Ответ:
Да, данные из PTY можно вывести на какой-либо из эмуляторов TTY, перенаправив данные на него. 
Для того, чтобы наблюдать выводимые данные, нам необходимо переключится в соответствующий эмулятор терминала, воспользовавшись сочетанием клавиш CTRL+ALT+F1..6 либо командой chvt <1..6>

7.Выполните команду bash 5>&1. К чему она приведет? Что будет, если вы выполните echo netology > /proc/$$/fd/5? Почему так происходит?

Ответ:
Команда bash 5>&1 создает новый файловый дескриптор 5(fd5) и перенаправляет его на STDOUT(1).
В результате, мы получили дополнительно к существующим стандартным файловым дискриптерам(0,1,2) новый(5), который, при направлении потоков к нему, будет перенаправлять их на fd1(STDOUT) 

Таким образом, при направлении потока на наш вновь созданный fd 5 командой:
echo netology > /proc/$$/fd/5
команда echo направит "netology" к fd5, который сделает редирект на fd1(STDOUT), в результате чего мы увидим на экране результат выполнения команды echo, т.е. netology 

8. Получится ли в качестве входного потока для pipe использовать только stderr команды, не потеряв при этом отображение stdout на pty? 
Напоминаем: по умолчанию через pipe передается только stdout команды слева от | на stdin команды справа. 
Это можно сделать, поменяв стандартные потоки местами через промежуточный новый дескриптор, который вы научились создавать в предыдущем вопросе.

Ответ: Да, например используя такую конструкцию (где temp2.file - существующий файл; n1.txt , n2.txt - не существующие файлы):
vagrant@vagrant:/home$ ls -lsa temp2.file n1.txt n2.txt 2>&1 1>&5 | grep "1"
ls: cannot access 'n1.txt': No such file or directory
0 -rwxrwxrwx 1 root root 0 Mar 29 21:18 temp2.file

Т.е. fd1(STDOUT) перенаправляется на fd5 из предыдущего задания(1>&5), fd5, в свою очередь, перенаправляет поток на fd1(STDOUT)- таким образом мы по прежнему увидим отображение stdout на pty.
0 -rwxrwxrwx 1 root root 0 Mar 29 21:18 temp2.file
Далее, для того, чтобы использовать в качестве входного потока для pipe поток stderr, перенаправляем stderr на stdout, в результате чего через pipe передастся через stdout то, что было в потоке stderr,
и grep отфильтрует только строки, в которых присутствует символ "1"
ls: cannot access 'n1.txt': No such file or directory


9.Что выведет команда cat /proc/$$/environ? Как еще можно получить аналогичный по содержанию вывод?  

Ответ:
Будет выведен перечень значений переменных окружения системы.
Подобного результата мы можем достичь, выполнив команды env либо export.

10. Используя man, опишите что доступно по адресам /proc/<PID>/cmdline, /proc/<PID>/exe.


Ответ:
/proc/[pid]/cmdline
Этот read-only файл содержит полную командную строку для процесса, если этот процесс не является зомби. В последнем случае в этом файле ничего нет: то есть чтение этого файла вернет 0 символов. 
Аргументы командной строки в этом файле отображаются в виде набора строк, разделенных нулевыми байтами ('\0'), с еще одним нулевым байтом после последней строки.
             
/proc/[pid]/exe
В Linux 2.2 и более поздних версиях этот файл представляет собой символическую ссылку, содержащую фактический путь к выполняемой команде. 
Эта символическая ссылка может быть разыменована обычным образом; попытка открыть его откроет исполняемый файл. Вы даже можете ввести /proc/[pid]/exe для запуска другой копии того же исполняемого файла, 
который запускается процессом [pid]. 
Под Linux 2.0 и в более ранних версиях exe является указателем на запущенный файл и является символьной ссылкой. Вызов readlink(2) на этот специальный файл exe под Linux 2.0 и более ранних версий возвращает строку формата:
[устройство]:индексный_дескриптор
Например, строка [0301]:1502 означает индексный дескриптор 1502 на устройстве со старшим номером устройства 03 (IDE, MFM и т. д.) и младшим номером устройства 01 (первый раздел на первом диске).
Для того, чтобы найти этот файл, может быть использована команда find(1) с опцией -inum.


11. Узнайте, какую наиболее старшую версию набора инструкций SSE поддерживает ваш процессор с помощью /proc/cpuinfo.

Ответ:
vagrant@vagrant:/home$ grep sse /proc/cpuinfo

Согласно выводу, наиболее старшей версией является набор инструкций sse4_2

12. При открытии нового окна терминала и vagrant ssh создается новая сессия и выделяется pty. Это можно подтвердить командой tty, которая упоминалась в лекции 3.2. Однако:
vagrant@netology1:~$ ssh localhost 'tty'
not a tty
Почитайте, почему так происходит, и как изменить поведение.

Ответ:
При входе в shell удаленный хост предполагает, что соединение выполняется пользователем- человеком. Если удаленный хост обнаруживает, 
что пользователь не является человеком, он предупреждает пользователя об этом неожиданном состоянии. 
Можно использовать флаг -t для принудительного создания псевдотерминала.


13. Бывает, что есть необходимость переместить запущенный процесс из одной сессии в другую. Попробуйте сделать это, воспользовавшись reptyr. 
Например, так можно перенести в screen процесс, который вы запустили по ошибке в обычной SSH-сессии.


Ответ:
reptyr — это утилита командной строки, которая берет запущенный процесс с одного терминала и переносит его на другой. Другими словами, утилита повторяет процесс.
reptyr работает, присоединяясь к целевой программе с помощью ptrace(2), перенаправляя соответствующие файловые дескрипторы и изменяя управляющий терминал программы.
После присоединения программы программа будет работать в фоновом режиме или приостановлена в оболочке, из которой она была запущена (в зависимости от оболочки).


14. sudo echo string > /root/new_file не даст выполнить перенаправление под обычным пользователем, так как перенаправлением занимается процесс shell'а, который запущен без sudo под вашим пользователем. 
Для решения данной проблемы можно использовать конструкцию echo string | sudo tee /root/new_file. Узнайте что делает команда tee и почему в отличие от sudo echo команда с sudo tee будет работать.


Ответ:
Команда tee - Команда tee считывает стандартный stdin и записывает его одновременно в стандартный stdout и в один или несколько подготовленных файлов. 
При обычном перенаправлении потока вывода строки команды будут записаны в файл, но мы не сможем увидеть вывод одновременно. 
Эта команда часто используется в сценариях командной оболочки для отображения хода процесса при выводе одних и тех же записей в файлы журналов. 

sudo echo string > /root/new_file
Приведенная выше команда sudo привела к ошибке permission denied, поскольку перенаправлением занимается процесс shell'а, который запущен без sudo под пользователем, у которого нет разрешения на запись.
Мы можем использовать команду sudo с командой tee, чтобы устранить эту ошибку:
echo string | sudo tee /root/new_file
При использовании описанного выше подхода команда, выполняемая перед пайпом, не будет выполняться от имени пользователя root (echo string).
Это полезно, если нам просто нужен вывод программы, для которой не требуются привилегии root.









 



 


